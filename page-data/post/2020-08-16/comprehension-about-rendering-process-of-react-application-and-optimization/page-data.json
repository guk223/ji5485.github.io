{"componentChunkName":"component---src-page-template-blog-post-item-template-tsx","path":"/post/2020-08-16/comprehension-about-rendering-process-of-react-application-and-optimization/","result":{"data":{"markdownRemark":{"html":"<h2 id=\"how-react-execute-rendering-process\" style=\"position:relative;\"><a href=\"#how-react-execute-rendering-process\" aria-label=\"how react execute rendering process permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>How React execute Rendering Process?</h2>\n<ol>\n<li>When Props Changed</li>\n<li>When State Changed</li>\n<li>When <code class=\"language-text\">forceUpdate()</code> executed</li>\n<li>When Parent Component rendered</li>\n</ol>\n<p>1~3번 과정을 통해 컴포넌트가 렌더링 된 경우에는 자식 컴포넌트 또한 같은 과정으로 렌더링 됨</p>\n<h3 id=\"what-we-used-previously-for-optimization-of-rendering-process\" style=\"position:relative;\"><a href=\"#what-we-used-previously-for-optimization-of-rendering-process\" aria-label=\"what we used previously for optimization of rendering process permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>What we used previously for Optimization of Rendering Process?</h3>\n<ol>\n<li>\n<p>shouldComponentUpdate LifeCycle API</p>\n<p>해당 라이프사이클 API에서는 인자값을 통해 변경되는 속성과 상태를 수신할 수 있기 때문에 이전과 그대로인 경우에는 거짓을 반환하여 렌더링을 수행하지 않도록 할 수 있음</p>\n</li>\n<li>\n<p>React.PureComponent Class</p>\n<p>변경되는 데이터가 모두 원시 값이거나 각각의 불변성을 보장할 수 있는 경우에는 해당 클래스 또는 함수를 사용할 수 있음</p>\n<p>넘겨받는 Props와 State를 Swallow 비교를 통해 렌더링 여부를 결정하기 때문에 불변성에 대한 중요도가 높음</p>\n</li>\n<li>\n<p>React.memo Function</p>\n<p>1번, 2번 방식을 모두 합쳐 놓은 것이지만 함수형 컴포넌트를 위한 최적화 함수</p>\n<p>함수형 컴포넌트만 인자값으로 넣으면 해당 함수형 컴포넌트는 PureComponent처럼 작동하지만, 두 번째 인자 값으로 현재 Props와 변경될 Props를 받아 직접 렌더링 제어도 가능</p>\n</li>\n</ol>\n<h3 id=\"case-of-passing-by-unaware-of-immutability\" style=\"position:relative;\"><a href=\"#case-of-passing-by-unaware-of-immutability\" aria-label=\"case of passing by unaware of immutability permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Case of Passing By Unaware of Immutability</h3>\n<ol>\n<li>\n<p>Props and State are Array or Object</p>\n<p>배열과 객체는 문자열, 숫자, 불리언 같은 원시형 데이터와는 다르게 변경 가능한 데이터이므로 동일함을 증명하기 위해서는 모든 내부에 있는 불변 데이터가 동일하다는 것을 입증해야 함</p>\n</li>\n<li>\n<p>Props and State are Function</p>\n<p>함수 또한 객체와 마찬가지로 불변 데이터가 아님</p>\n<p>특히 리터럴 함수 형태로 Props를 넘겨주는 경우에는 자식 컴포넌트가 렌더링 되는 모든 시점에서 똑같은 함수가 계속해서 재생성된다.</p>\n</li>\n<li>\n<p>Props and State are React Element</p>\n<p>우리가 편하게 작성하는 마크업 구조의 React Element 또한 children이라는 Key 값으로 전달되는 Props이므로 불필요하게 렌더링 되는 대상이다.</p>\n</li>\n</ol>\n<h3 id=\"solutions-about-above-problems\" style=\"position:relative;\"><a href=\"#solutions-about-above-problems\" aria-label=\"solutions about above problems permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Solutions about Above Problems</h3>\n<ol>\n<li>\n<p>Case of Fixed Constant Data</p>\n<p>렌더링 단계에서 생성하는 것이 아닌 정적으로 생성하여 넘겨주는 방법</p>\n<p>해당 컴포넌트에서 값을 분리하여 사용한다.</p>\n</li>\n<li>\n<p>Case of Data that doesn’t require an immediate response</p>\n<p>주로 이벤트 핸들러와 같은 함수 Props에 해당</p>\n<p>따로 프로퍼티로 함수를 만들어 이를 Props로 넘기는 방법</p>\n<p>해당 프로퍼티를 가지고 있는 컴포넌트에서 렌더링이 발생하지 않는 이상 기존 함수는 새로 생성되지 않음</p>\n</li>\n<li>\n<p>Case of Data that requires an immediate response</p>\n<p>메모이제이션 기법을 통해 동일한 계산의 반복 수행을 제거하는 방법</p>\n</li>\n</ol>\n<h3 id=\"optimize-rendering-process-with-hooks\" style=\"position:relative;\"><a href=\"#optimize-rendering-process-with-hooks\" aria-label=\"optimize rendering process with hooks permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Optimize Rendering Process with Hooks</h3>\n<ol>\n<li>\n<p>useMemo</p>\n<p>메모이제이션 된 값을 반환받는 Hook</p>\n<p>의존성을 배열 형태로 받아 메모이제이션 값이 변경되는 시점을 결정</p>\n</li>\n<li>\n<p>useCallback</p>\n<p>특정 함수를 새로 만들지 않고 재사용해야하는 경우에 사용하는 Hook</p>\n<p>의존성을 배열 형태로 받아 메모이제이션 값이 변경되는 시점을 결정</p>\n</li>\n</ol>","frontmatter":{"title":"Comprehension about Rendering Process of React Application and Optimization","date":"2020-08-16","summary":"오픈소스 웹 애플리케이션 보안 프로젝트 OWASP에서 선정한 웹 취약점에 항상 이름을 올리는 XSS와 CSRF은 무엇이고, 해당 해킹 기법에 대한 조치 방법으로는 무엇이 있을까?","categories":["Web","Frontend","OpenSource","Optimization"],"thumbnail":{"childImageSharp":{"fluid":{"base64":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAIAAADtbgqsAAAACXBIWXMAAAsTAAALEwEAmpwYAAAB9klEQVQoz2PQ3hYGR5pbQzS3hmphII0tIdpbw0BoGwpiQOMDNYONQEFa20LhCItmnW1hGltDbPakeB7Itd6bZLsvBY7s96X5HS7W3RlhsDNSZ3s4dps1t4QY7Yn1XZtjGeVlFedtFeNtFe5pFettHefjlhFhEuVuEeNlsz5Bc2co3P0IzVpbQg32xbgsTFTW1FPR0lOxMlErcFLRN1BV1zO2tlPR0VfXNbRcGaO1Kwyb5q2hBntjHOamaBgZaxgba1maakbbaVibaRe7mbu7qBsaaZmaWa2KxaZ5a5ju9lDJFVGqLYnqevoqpsbSntaqynoaNa5axyJNGwPUtA00TEwNl0Zro2nW2hqmvzNMenmw8IxUm4lFZpY2KlmBfBMS9ZuCrfYlWu9NDjhZqp5qr6VjrDA/Un5riC4iwIB27ghT3RDG3BPKNDFapS5WwceesS2cf1KY7pZwvQ1heuvDjDdHaa0J0va2UpgRxr0mUH1zqM52sGYIxTk5jKEjjKE3VKI1VqkkRK4xWLMjWLcnWAeMtLuDdPtD9ZuC5BdFcqzwF1oZCIxwYOwyAK3lnwXSydgTxtAVxtgXzrssVHBNMN9KVLQimG9NCM/KQJ7lAVzLAkTXBIE0SywC29kNRl1h7HOCeFb4cy/z516OBQF1QhBQv/S6YABUaQHMW8wiKgAAAABJRU5ErkJggg==","aspectRatio":1.6991150442477876,"src":"/static/6d912ac40ee5b5c4e79205f9082c8c3e/44785/abc_copy.png","srcSet":"/static/6d912ac40ee5b5c4e79205f9082c8c3e/1e67e/abc_copy.png 192w,\n/static/6d912ac40ee5b5c4e79205f9082c8c3e/7ad7b/abc_copy.png 384w,\n/static/6d912ac40ee5b5c4e79205f9082c8c3e/44785/abc_copy.png 768w,\n/static/6d912ac40ee5b5c4e79205f9082c8c3e/263b8/abc_copy.png 780w","srcWebp":"/static/6d912ac40ee5b5c4e79205f9082c8c3e/499b6/abc_copy.webp","srcSetWebp":"/static/6d912ac40ee5b5c4e79205f9082c8c3e/bad1d/abc_copy.webp 192w,\n/static/6d912ac40ee5b5c4e79205f9082c8c3e/d7772/abc_copy.webp 384w,\n/static/6d912ac40ee5b5c4e79205f9082c8c3e/499b6/abc_copy.webp 768w,\n/static/6d912ac40ee5b5c4e79205f9082c8c3e/67a76/abc_copy.webp 780w","sizes":"(max-width: 768px) 100vw, 768px"}}}},"tableOfContents":"<ul>\n<li>\n<p><a href=\"/post/2020-08-16/comprehension-about-rendering-process-of-react-application-and-optimization/#how-react-execute-rendering-process\">How React execute Rendering Process?</a></p>\n<ul>\n<li><a href=\"/post/2020-08-16/comprehension-about-rendering-process-of-react-application-and-optimization/#what-we-used-previously-for-optimization-of-rendering-process\">What we used previously for Optimization of Rendering Process?</a></li>\n<li><a href=\"/post/2020-08-16/comprehension-about-rendering-process-of-react-application-and-optimization/#case-of-passing-by-unaware-of-immutability\">Case of Passing By Unaware of Immutability</a></li>\n<li><a href=\"/post/2020-08-16/comprehension-about-rendering-process-of-react-application-and-optimization/#solutions-about-above-problems\">Solutions about Above Problems</a></li>\n<li><a href=\"/post/2020-08-16/comprehension-about-rendering-process-of-react-application-and-optimization/#optimize-rendering-process-with-hooks\">Optimize Rendering Process with Hooks</a></li>\n</ul>\n</li>\n</ul>"},"site":{"siteMetadata":{"siteUrl":"https://ji5485.github.io"}}},"pageContext":{"slug":"/post/2020-08-16/comprehension-about-rendering-process-of-react-application-and-optimization/","prev":{"slug":"/post/2020-08-17/when-to-usememo-and-usecallback/","title":"When to useMemo and useCallback"},"next":{"slug":"/post/2020-08-08/ioc-container-in-spring/","title":"IoC Container in Spring"}}},"staticQueryHashes":[]}